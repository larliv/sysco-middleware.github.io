I"‹n<p>One of the most important features from <em>Apache Kafka</em> is how it manages
Multiple Consumers. Each <code class="highlighter-rouge">consumer group</code> has a current <code class="highlighter-rouge">offset</code>, that
determine at what point in a <code class="highlighter-rouge">topic</code> this <code class="highlighter-rouge">consumer group</code> has consume
messages. So, each <code class="highlighter-rouge">consumer group</code> can manage its <code class="highlighter-rouge">offset</code> independently,
by <code class="highlighter-rouge">partition</code>.</p>

<p>This offers the possibility to rollback in time and reprocess messages from
the beginning of a <code class="highlighter-rouge">topic</code> and regenerate the current status of the system.</p>

<p>But how to do it (programmatically)?</p>

<!--more-->

<hr />
<p>Source code: <a href="https://github.com/jeqo/post-kafka-rewind-consumer-offset">https://github.com/jeqo/post-kafka-rewind-consumer-offset</a>
<em>**</em></p>

<h2 id="basic-concepts">Basic Concepts</h2>

<h3 id="topics-and-offsets">Topics and Offsets</h3>

<p>First thing to understand to achieve Consumer Rewind, is: rewind over what?
Because <code class="highlighter-rouge">topics</code> are divided into <code class="highlighter-rouge">partitions</code>. Records sent from <code class="highlighter-rouge">Producers</code>
are balanced between them, so each partition has its own <code class="highlighter-rouge">offset</code> index.</p>

<p>Each <code class="highlighter-rouge">record</code> has its own <code class="highlighter-rouge">offset</code> that will be used by <code class="highlighter-rouge">consumers</code> to define
which messages has been consumed from the <strong>log</strong>.</p>

<h3 id="consumers-and-consumer-groups">Consumers and Consumer Groups</h3>

<p>Once we understand that <code class="highlighter-rouge">topics</code> have <code class="highlighter-rouge">partitions</code> and <code class="highlighter-rouge">offsets</code> by <code class="highlighter-rouge">partition</code>
we can now understand how <code class="highlighter-rouge">consumers</code> and <code class="highlighter-rouge">consumer groups</code> work.</p>

<p><code class="highlighter-rouge">Consumers</code> are grouped by <code class="highlighter-rouge">group.id</code>. This property identify you as a
<code class="highlighter-rouge">consumer group</code>, so the <code class="highlighter-rouge">broker</code> knows which was the last <code class="highlighter-rouge">record</code> you have
consumed by <code class="highlighter-rouge">offset</code>, by <code class="highlighter-rouge">partition</code>.</p>

<p>This partitions allows <em>parallelism</em>, because members from a <code class="highlighter-rouge">consumer group</code>
can consume <code class="highlighter-rouge">records</code> from <code class="highlighter-rouge">partitions</code> independently, in parallel.</p>

<p>Before continue, letâ€™s check a simple Kafka Producer implemented with Java:</p>

<p><code class="highlighter-rouge">KafkaSimpleProducer.java</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nc">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
    <span class="n">properties</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ProducerConfig</span><span class="o">.</span><span class="na">BOOTSTRAP_SERVERS_CONFIG</span><span class="o">,</span> <span class="n">bootstrapServers</span><span class="o">);</span>
    <span class="n">properties</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ProducerConfig</span><span class="o">.</span><span class="na">KEY_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="nc">StringSerializer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">properties</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ProducerConfig</span><span class="o">.</span><span class="na">VALUE_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="nc">StringSerializer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

    <span class="nc">Producer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaProducer</span><span class="o">&lt;&gt;(</span><span class="n">properties</span><span class="o">);</span>

    <span class="nc">IntStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
            <span class="o">.</span><span class="na">boxed</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">number</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ProducerRecord</span><span class="o">&lt;&gt;(</span>
                    <span class="s">"topic-1"</span><span class="o">,</span>
                    <span class="n">number</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span>
                    <span class="n">number</span><span class="o">.</span><span class="na">toString</span><span class="o">()))</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">record</span> <span class="o">-&gt;</span> <span class="n">producer</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">record</span><span class="o">))</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="n">printMetadata</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
    <span class="n">producer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This will create 100 <code class="highlighter-rouge">records</code> in topic <code class="highlighter-rouge">topic-1</code>, with <code class="highlighter-rouge">offsets</code> from 0-99</p>

<h2 id="from-command-line">From Command-Line</h2>

<p>In this first scenario, we will see how to manage offsets from <em>command-line</em>
so it will give us an idea of how to implement it in our application.</p>

<p>When youâ€™re working from the terminal, you can use <code class="highlighter-rouge">kafka-console-consumer</code> without
<code class="highlighter-rouge">group.id</code>, a new <code class="highlighter-rouge">group.id</code> is generated using:
<code class="highlighter-rouge">console-consumer-${new Random().nextInt(100000)}</code>.
So unless you use the same <code class="highlighter-rouge">group.id</code> afterwards, it would be as you create a
new consumer group each time.</p>

<p>By default, when you connect to a <code class="highlighter-rouge">topic</code> as a <code class="highlighter-rouge">consumer</code>, you
go to the <em>latest</em> <code class="highlighter-rouge">offset</code>, so you wonâ€™t see any new message until new records
arrive after you connect.</p>

<p>In this case, going back to the beginning of the topic will as easy as add
<code class="highlighter-rouge">--from-beginning</code> option to the command line:</p>

<script type="text/javascript" src="https://asciinema.org/a/101246.js" id="asciicast-101246" async=""></script>

<p>But, what happen if you use <code class="highlighter-rouge">group.id</code> property, it will only work the first time,
but <code class="highlighter-rouge">offset</code> gets commited to cluster:</p>

<script type="text/javascript" src="https://asciinema.org/a/101248.js" id="asciicast-101248" async=""></script>

<script type="text/javascript" src="https://asciinema.org/a/101250.js" id="asciicast-101250" async=""></script>

<p>So, how to go back to the beginning?</p>

<p>We can use <code class="highlighter-rouge">--offset</code> option to with three alternatives:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--offset &lt;String: consume offset&gt;        The offset id to consume from (a non-  
                                           negative number), or 'earliest'      
                                           which means from beginning, or       
                                           'latest' which means from end        
                                           (default: latest)
</code></pre></div></div>

<script type="text/javascript" src="https://asciinema.org/a/101252.js" id="asciicast-101252" async=""></script>

<h2 id="from-java-clients">From Java Clients</h2>

<p>So, from <code class="highlighter-rouge">command-line</code> is pretty easy to go back in time in the log. But
how to do it from your application?</p>

<p>If youâ€™re using Kafka Consumers in your applications, you have to options
(with Java):</p>

<ul>
  <li>
    <p><a href="http://kafka.apache.org/documentation/#consumerapi">Kafka Consumer API</a></p>
  </li>
  <li>
    <p><a href="http://kafka.apache.org/documentation/#streamsapi">Kafka Streams API</a></p>
  </li>
</ul>

<p>Long story short: If you need stateful and stream processing capabilities,
go with Kafka Streams.
If you need simple one-by-one consumption of messages by topics, go with
Kafka Consumer.</p>

<p>At this moment this are the options to rewind offsets with these APIs:</p>

<ul>
  <li>
    <p>Kafka Consumer API support go back to the beginning of the topic, go back
to a specific offset, and go back to a specific offset by timestamps.</p>
  </li>
  <li>
    <p>Kafka Streams API only support to go back to the earliest offset of the
<code class="highlighter-rouge">input topics</code>, and is well explained by <a href="https://github.com/mjsax">Matthias J. Sax</a>
in his post
<a href="https://www.confluent.io/blog/data-reprocessing-with-kafka-streams-resetting-a-streams-application/">[1]</a>.</p>
  </li>
</ul>

<p>So I will focus in options available in <code class="highlighter-rouge">Kafka Consumer</code>.</p>

<p>A simple Consumer will look something like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
    <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ConsumerConfig</span><span class="o">.</span><span class="na">BOOTSTRAP_SERVERS_CONFIG</span><span class="o">,</span> <span class="n">bootstrapServers</span><span class="o">);</span>
    <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ConsumerConfig</span><span class="o">.</span><span class="na">GROUP_ID_CONFIG</span><span class="o">,</span> <span class="s">"test"</span><span class="o">);</span>
    <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ConsumerConfig</span><span class="o">.</span><span class="na">ENABLE_AUTO_COMMIT_CONFIG</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span>
    <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ConsumerConfig</span><span class="o">.</span><span class="na">KEY_DESERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="s">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="o">);</span>
    <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">ConsumerConfig</span><span class="o">.</span><span class="na">VALUE_DESERIALIZER_CLASS_CONFIG</span><span class="o">,</span> <span class="s">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="o">);</span>

    <span class="nc">KafkaConsumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaConsumer</span><span class="o">&lt;&gt;(</span><span class="n">props</span><span class="o">);</span>
    <span class="n">consumer</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"topic-1"</span><span class="o">));</span>

    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ConsumerRecords</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">ConsumerRecord</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">:</span> <span class="n">records</span><span class="o">)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"offset = %d, key = %s, value = %s%n"</span><span class="o">,</span> <span class="n">record</span><span class="o">.</span><span class="na">offset</span><span class="o">(),</span> <span class="n">record</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">record</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This will poll by <code class="highlighter-rouge">100ms</code> for records and print them out.  In this case
it should print 100 records.</p>

<p>Now letâ€™s check how to rewind <code class="highlighter-rouge">offsets</code> in different scenarios. Consumer API has
add <code class="highlighter-rouge">#seek</code> operations to achieve this behavior. I will show a naive way to use
these operations using flags but it shows the point:</p>

<h3 id="rewind-to-earliest-offset">Rewind to earliest <code class="highlighter-rouge">offset</code></h3>

<p>The most common options is to go back to the beginning of the topic, that not
always will be <code class="highlighter-rouge">offset=0</code>. This will depends on the <code class="highlighter-rouge">retention</code> policy
option that will be clean up old records based on time or size; but
this also deserves its own post.</p>

<p>To go to the beginning we can use <code class="highlighter-rouge">#seekToBeginning(topicPartition)</code>
operation to go back to earliest offset:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ConsumerRecords</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">seekToBeginning</span><span class="o">(</span>
            <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">TopicPartition</span><span class="o">(</span><span class="s">"topic-1"</span><span class="o">,</span> <span class="mi">0</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">()));</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">ConsumerRecord</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">:</span> <span class="n">records</span><span class="o">)</span>
        <span class="c1">//Consume record</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Once the seek to beginnning is done, it will reprocess all records from
<code class="highlighter-rouge">topic=topic-1</code> and <code class="highlighter-rouge">partition=0</code>.</p>

<h3 id="rewind-to-specific-offset">Rewind to specific <code class="highlighter-rouge">offset</code></h3>

<p>If we can recognized the specific <code class="highlighter-rouge">record</code> (by <code class="highlighter-rouge">partition</code>)
from where we need to reprocess all the log,
we can use <code class="highlighter-rouge">#seek(topicPartition, offset)</code> directly.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ConsumerRecords</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>

    <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="k">new</span> <span class="nc">TopicPartition</span><span class="o">(</span><span class="s">"topic-1"</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="mi">90</span><span class="o">);</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">ConsumerRecord</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">:</span> <span class="n">records</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"offset = %d, key = %s, value = %s%n"</span><span class="o">,</span> <span class="n">record</span><span class="o">.</span><span class="na">offset</span><span class="o">(),</span> <span class="n">record</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">record</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this case, we will consume from <code class="highlighter-rouge">record</code> with <code class="highlighter-rouge">offset=90</code>from
<code class="highlighter-rouge">topic=topic-1</code> and <code class="highlighter-rouge">partition=0</code>.</p>

<hr />
<p>NOTE: It could be cumbersome to map all offsets in case that you have
several partitions. Thats why addition of timestamps helps a lot with this.
***</p>

<h3 id="rewind-to-offset-by-timestamps">Rewind to offset by timestamps</h3>

<p>What if you donâ€™t know exactly the <code class="highlighter-rouge">offset id</code> to go back to, but you know
you want to go back 1 hour or 10 min?</p>

<p>For these, since release <code class="highlighter-rouge">0.10.1.0</code>, there are a couple of
improvements <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-32+-+Add+timestamps+to+Kafka+message">[2]</a>
<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-33+-+Add+a+time+based+log+index">[3]</a>
were added and a new operation was added to <code class="highlighter-rouge">Kafka Consumer API</code>: <code class="highlighter-rouge">#offsetsForTimes</code>.</p>

<p>Here is how to use it:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ConsumerRecords</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>

    <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TopicPartition</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">query</span><span class="o">.</span><span class="na">put</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">TopicPartition</span><span class="o">(</span><span class="s">"simple-topic-1"</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
                <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minus</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="no">MINUTES</span><span class="o">).</span><span class="na">toEpochMilli</span><span class="o">());</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">TopicPartition</span><span class="o">,</span> <span class="nc">OffsetAndTimestamp</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">offsetsForTimes</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>

        <span class="n">result</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">entry</span> <span class="o">-&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">offset</span><span class="o">()));</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">ConsumerRecord</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">:</span> <span class="n">records</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"offset = %d, key = %s, value = %s%n"</span><span class="o">,</span> <span class="n">record</span><span class="o">.</span><span class="na">offset</span><span class="o">(),</span> <span class="n">record</span><span class="o">.</span><span class="na">key</span><span class="o">(),</span> <span class="n">record</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this case, we are using a query first to get the offset inside a timestamp (10 minutes ago)
and then using that offset to go back with <code class="highlighter-rouge">#seek</code> operation.</p>

<p>As you can see, for each operation I have to define the specific <code class="highlighter-rouge">topic partition</code>
to go back to, so this can get tricky if you have more than one partition, so I
would recommend to use <code class="highlighter-rouge">#offsetsForTimes</code> in those cases to get an aligned result
and avoid inconsistencies in your consumers.</p>

<p>In the source code, Iâ€™ve added the steps to get partitions by topic that will
help us to reproduce this steps when you have several topics.</p>

<hr />
<p><strong>References</strong></p>

<ol>
  <li>
    <p>https://www.confluent.io/blog/data-reprocessing-with-kafka-streams-resetting-a-streams-application/</p>
  </li>
  <li>
    <p>https://cwiki.apache.org/confluence/display/KAFKA/KIP-32+-+Add+timestamps+to+Kafka+message</p>
  </li>
  <li>
    <p>https://cwiki.apache.org/confluence/display/KAFKA/KIP-33+-+Add+a+time+based+log+index</p>
  </li>
  <li>
    <p>https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-HowcanIrewindtheoffsetintheconsumer</p>
  </li>
</ol>

<hr />

<hr />
<p>Published originally here: <a href="https://jeqo.github.io/post/2017-01-31-kafka-rewind-consumers-offset/">https://jeqo.github.io/post/2017-01-31-kafka-rewind-consumers-offset/</a></p>

<hr />
:ET